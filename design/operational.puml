@startuml

' Copyright (C) 2014-2015  Thilo Fischer.
' Free for non-commercial and most commercial use. See LICENSE.txt for details.

note as N1
  This diagram does not depict the current
  implemention, but the planned rework of it.
end note

class Session {
  ' All the main_files of the translation units that make up the modules
  input_files() : File
}
note right: formally known as Environment
Logger "1" -- "1" Session : logger <
' From the Elements UML diagram
Element "1" <-- "0..1" Session : cursor <
Directory "0..n" <-- "0..n" Session : include_dirs <
Module "1..n" <-- "1" Session : modules <

class Options {
  + on_the_fly?()
  ' path to the cache directory, Session will create its cache from this
  + cache_dir()
  ' emulate a certain compilers command line argument processing (and possibly other behaviour)
  + compiler() : gcc, ...
  + language() : C, C++
  + dialect() : ANSI-C, C-99, ...
  - cmdline_options : Map
  - compiler
}
Session "1" --> "1" Options : options >
Compiler "0..1" <-- "0..n" Options : compiler (private) <

class Cache {
  + root_dir : String
}
' No cache only for on-the-fly invokations
Session "1" -- "0..1" Cache : cache >

class ParsingContext {
}

ParsingContext --> LinereadContext
PhysicalLine "0..n" <-- LinereadContext : ongoing_lines

ParsingContext --> CommentContext
' Refers to a comment if the comment's beginning has already been parsed, but the comment's ending has not yet been found (e.g. block comments that span several lines)
CommentContext "1" --> "0..1" MultilineComment : ongoing_comment

ParsingContext --> CompilationContext
class CompilationContext {
}
CompilationContext "1" <--> "1..n" CompilationBranch : branches

class TokenizationContext {
' remaining charactres of current line to tokenize
+ remainder : String
}
CommentContext "1" <-- "0..n" TokenizationContext : comment_context >

' array of all preprocessing conditional branches chosen
PpDirCond "0..1" <-- "0..1" CompilationBranch : conditions >

Token "0..1" <-- CompilationBranch : cursor

' Which namespace, class, function, compound statement, etc. are we in at the current position in source code (formally known as expansion_stack)
Element "1..n" <-- CompilationBranch : scope_stack <

class TranslationUnit {
  + announce_pp_dir_line(pp_line_directive)
  + pp_line_number(line, conditions) : int
  + announce_symbol(symbol)
  + announce_reference(reference)
}
CompilationContext "1" --> "1" TranslationUnit : translation_unit >
PpDirLine "0..n" <-- TranslationUnit : line_directives <

class SymbolIndex {
+ announce_symbol(symbol)
+ find_symbols(identifier :String, namespace = nil, class = nil, linkage = none, conditions = nil) : Symbol[]
+ find_innermost_symbol(identifier :String, namespace = nil, class = nil, linkage = none) : Symbol
+ find_function(identifier, linkage = external) alias find_innermost_symbol(identifier, :ordinary, Function, linkage) : Function
+ find_variable(identifier, linkage = external) alias find_innermost_symbol(identifier, :ordinary, Variable, linkage) : Variable
+ find_macro(identifier) alias find_innermost_symbol(identifier, :macros, Macro, nil/internal) : Macro
+ ...
}
TranslationUnit "1" --> "1" SymbolIndex : symbols >
SymbolIndex "1" --> "0..n" Symbol : map

TranslationUnit "1" --> "1" ReferenceIndex : symbols >
ReferenceIndex "1" --> "0..n" Reference : map

@enduml