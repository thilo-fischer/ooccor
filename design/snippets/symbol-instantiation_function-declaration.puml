@startuml

legend center
  Copyright (c) 2014-2016  Thilo Fischer.
  
  This diagram is part of the developer documentation of rocc.
 
  rocc is free software with a multi-license approach: you can
  redistribute it and/or modify it as if it was under the terms of the
  GNU General Public License as long as the things you publish to
  satisfy the GPL's copyleft still can be integrated into the rocc
  project's main codebase without restricting the multi-license
  approach. See LICENSE.txt from the top-level directory for details.
 
  The same license applies to this document.

  --

  The rocc architecture is work in progress.  Deviations of the diagram
  from the actual source code (or vice versa) must be expected.
endlegend

skinparam monochrome true

title Function Declaration

participant TranslationUnit
participant CompilationContext
participant Token
participant CompilationBranch
participant "a : ArisingSpecification" as ArisingSpecification
participant "s : Function < Symbol" as Symbol
participant "d : Declaration" as Declaration
participant "f : FunctionSignature" as FunctionSignature

... parsed optional storage class, type qualifier, type specifier and parsed identifier ...

[-> Token : pursue_branch
rnote over Token : ""(""
activate Token

note over ArisingSpecification : CompilationBranch#\ncurrent_scope

Token -> CompilationBranch : current_scope
activate CompilationBranch
Token <-- CompilationBranch : a
deactivate CompilationBranch

Token -> ArisingSpecification : mark_as_function

create FunctionSignature
Token -> FunctionSignature : new
Token -> CompilationBranch : enter_scope(f)
note over FunctionSignature : CompilationBranch#\ncurrent_scope

[<-- Token
deactivate Token

... parse function parameters ...

[-> Token : pursue_branch
rnote over Token : "")""
activate Token

Token -> CompilationBranch : finish_current_scope
activate CompilationBranch
note over FunctionSignature : CompilationBranch#\ncurrent_scope
CompilationBranch -> FunctionSignature : finalize
CompilationBranch -> CompilationBranch : leave_scope
note over ArisingSpecification : CompilationBranch#\ncurrent_scope
Token <-- CompilationBranch : f
deactivate CompilationBranch

Token -> CompilationBranch : current_scope
activate CompilationBranch
Token <-- CompilationBranch : a
deactivate CompilationBranch

Token -> ArisingSpecification : signature=(f)

[<-- Token
deactivate Token

[-> Token : pursue_branch

'rnote over Token : "";"" or "",""
rnote over Token : "";""

activate Token

Token -> CompilationBranch : finish_current_scope
activate CompilationBranch

CompilationBranch -> ArisingSpecification : finalize
activate ArisingSpecification

ArisingSpecification -> CompilationContext : find_symbols(identifier, namespace, signature)
activate CompilationContext
ArisingSpecification <-- CompilationContext : es
deactivate CompilationContext

alt es.empty?

  create Symbol
  ArisingSpecification -> Symbol : new

  ArisingSpecification -> CompilationContext : announce_symbol(s)
  'activate CompilationContext
  'CompilationBranch <-- CompilationContext : symbol
  'deactivate CompilationContext

else otherwise

  ArisingSpecification -> ArisingSpecification : s = es.first
  
end ' alt es.empty?

create Declaration
ArisingSpecification -> Declaration : new(s, conditions)

ArisingSpecification -> Symbol : announce_signature(d, f)
activate Symbol
ArisingSpecification <-- Symbol
deactivate Symbol

CompilationBranch <-- ArisingSpecification : d
deactivate ArisingSpecification

CompilationBranch -> CompilationBranch : leave_scope

destroy ArisingSpecification


CompilationBranch -> TranslationUnit : announce_semantic_element(d)
activate TranslationUnit
CompilationBranch <-- TranslationUnit
deactivate TranslationUnit

Token <-- CompilationBranch : d
deactivate CompilationBranch

[<-- Token
deactivate Token

@enduml

