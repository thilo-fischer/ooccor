@startuml

legend center
  Copyright (c) 2014-2016  Thilo Fischer.
  
  This diagram is part of the developer documentation of rocc.
 
  rocc is free software with a multi-license approach: you can
  redistribute it and/or modify it as if it was under the terms of the
  GNU General Public License as long as the things you publish to
  satisfy the GPL's copyleft still can be integrated into the rocc
  project's main codebase without restricting the multi-license
  approach. See LICENSE.txt from the top-level directory for details.
 
  The same license applies to this document.

  --

  The rocc architecture is work in progress.  Deviations of the diagram
  from the actual source code (or vice versa) must be expected.
endlegend

skinparam monochrome true

title Function Definition

participant TranslationUnit
participant CompilationContext
participant Token
participant CompilationBranch
participant "a : ArisingSpecification" as ArisingSpecification
participant "s : Function < Symbol" as Symbol
participant "d : FunctionDeclaration" as Declaration
participant "fs : FunctionSignature" as FunctionSignature
participant "D : Definition" as Definition
participant "c : CompoundStatement" as CompoundStatement
database "ScopeStack (part of\nCompilationBranch)" as ScopeStack

== same as function declaration >> ==

activate ScopeStack
rnote over ScopeStack : a

... parsed optional storage class, type qualifier, type specifier and parsed identifier ...

[-> Token : pursue_branch
rnote over Token : ""(""
activate Token

'note over ArisingSpecification : CompilationBranch#\ncurrent_scope

'Token -> CompilationBranch : current_scope
'activate CompilationBranch
'Token <-- CompilationBranch : a
'deactivate CompilationBranch

Token -> ArisingSpecification : mark_as_function

create FunctionSignature
Token -> FunctionSignature : new
Token -> CompilationBranch : enter_scope(fs)
activate ScopeStack
rnote over ScopeStack : fs
'note over FunctionSignature : CompilationBranch#\ncurrent_scope

[<-- Token
deactivate Token

... parse function parameters ...

[-> Token : pursue_branch
rnote over Token : "")""
activate Token

Token -> CompilationBranch : finish_current_scope
activate CompilationBranch
'note over FunctionSignature : CompilationBranch#\ncurrent_scope
CompilationBranch -> FunctionSignature : launch

rnote over ScopeStack : fs
CompilationBranch -> CompilationBranch : leave_scope
deactivate ScopeStack
'note over ArisingSpecification : CompilationBranch#\ncurrent_scope
rnote over ScopeStack : a

Token <-- CompilationBranch : fs
deactivate CompilationBranch

Token -> CompilationBranch : current_scope
activate CompilationBranch
Token <-- CompilationBranch : a
deactivate CompilationBranch

Token -> ArisingSpecification : signature=(fs)

[<-- Token
deactivate Token

== << same as function declaration ==

[-> Token : pursue_branch

rnote over Token : ""{""

activate Token

== same as function declaration >> ==

Token -> CompilationBranch : finish_current_scope
activate CompilationBranch

CompilationBranch -> ArisingSpecification : finalize

CompilationBranch -> ArisingSpecification : create_symbol
activate ArisingSpecification
create Symbol
ArisingSpecification -> Symbol : new
CompilationBranch <-- ArisingSpecification : s
deactivate ArisingSpecification

CompilationBranch -> CompilationContext : find_symbols(s)
activate CompilationContext
CompilationBranch <-- CompilationContext : existing_symbols
deactivate CompilationContext

alt existing_symbols.empty?

  CompilationBranch -> CompilationContext : announce_symbol(s)
  'activate CompilationContext
  'CompilationBranch <-- CompilationContext : symbol
  'deactivate CompilationContext

else otherwise

  note over Symbol : replace newly created symbol\nwith already existing symbol
  ArisingSpecification -> Symbol : s = existing_symbols.first
  destroy Symbol
  create Symbol
  ArisingSpecification -> Symbol : s = existing_symbols.first
  
end ' alt existing_symbols.empty?

'note over ArisingSpecification : CompilationBranch#\ncurrent_scope
CompilationBranch -> ArisingSpecification : launch_declaration(symbol)
activate ArisingSpecification

create Declaration
ArisingSpecification -> Declaration : new(s, fs, conditions)

Declaration -> FunctionSignature : param_names
Declaration <-- FunctionSignature : param_names
Declaration -> Declaration : param_names=(param_names)

== << same as function declaration ==

CompilationBranch <-- ArisingSpecification : d
deactivate ArisingSpecification

Token <-- CompilationBranch : d
deactivate CompilationBranch

create Definition
Token -> Definition : new(d)
Token -> CompilationBranch : enter_scope(D)
activate ScopeStack
rnote over ScopeStack : D
'note over Definition : CompilationBranch#\ncurrent_scope

create CompoundStatement
Token -> CompoundStatement : new
Token -> CompilationBranch : enter_scope(c)
activate ScopeStack
rnote over ScopeStack : c
'note over Initializer : CompilationBranch#\ncurrent_scope

[<-- Token
deactivate Token

... parse implementation (CompoundStatement) ...

[-> Token : pursue_branch
rnote over Token : ""}""

activate Token

Token -> CompilationBranch : finish_current_scope
activate CompilationBranch

'note over Initializer : CompilationBranch#\ncurrent_scope
CompilationBranch -> CompoundStatement : launch

rnote over ScopeStack : c
CompilationBranch -> CompilationBranch : leave_scope
deactivate ScopeStack
rnote over ScopeStack : D

'note over Definition : CompilationBranch#\ncurrent_scope

CompilationBranch -> Definition : add_body(c)

CompilationBranch -> Definition : launch
activate Definition

Definition -> Symbol : announce_definition(D)

CompilationBranch <-- Definition
deactivate Definition

rnote over ScopeStack : D
CompilationBranch -> CompilationBranch : leave_scope
deactivate ScopeStack

CompilationBranch -> TranslationUnit : announce_semantic_element(D)
activate TranslationUnit
CompilationBranch <-- TranslationUnit
deactivate TranslationUnit

Token <-- CompilationBranch : D
deactivate CompilationBranch

rnote over ScopeStack : a
Token -> CompilationBranch : leave_scope
deactivate ScopeStack
destroy ArisingSpecification
destroy FunctionSignature

[<-- Token
deactivate Token

note over TranslationUnit, ScopeStack
  Similar to Variable Definition. Deviations: Tokens that cause relevant pursuations, function signature related stuff (parsing of function signature, signature_types in find_symbols, announce_signature), CompoundStatement instead of Initializer
end note

@enduml

